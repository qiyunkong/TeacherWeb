<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>
  <script>
    //  回顾一下
    // function aa() {
    //   function bb() {
    //     var b = 666;
    //     console.log(a)
    //   }
    //   bb();
    //   var a = 10;
    //   console.log(cc)
    // }
    // var cc = 888;
    // aa();


    // 闭包

    // function aa() {
    //   function bb() {
    //     var b = 666;
    //     console.log(a)    // undefined  //10
    //   }
    //   bb();
    //   var a = 10;
    //   return bb;
    // }
    // var cc = 888;
    // var dd = aa();
    // dd();

    // 每一个函数都会记住自己定义时的作用域环境(父级作用域一直到全局作用域)
    // 函数执行是,函数内部创建自己的作用域,添加到自己出生时作用域环境的顶端
    // 正常来说一个函数执行完毕以后,自己的作用域会被垃圾回收机制销毁
    // 如果定义时的作用域环境被销毁,那么函数记住的所有作用域都会别销毁
    // 但是如果这个函数被挪到背的作用域中去定义了,那么函数将一直记住自己出生是的作用域环境
    // function outer() {
    //   var a = 100;
    //   function inner() {
    //     a++;
    //     console.log(a)
    //   }
    //   return inner;
    // }

    // var inn = outer();
    // inn()
    // inn()
    // inn()


    // function outer() {

    //   var a = 100;
    //   a++
    //   console.log(a)  // 101
    // }
    // outer()
    // outer()
    // outer()



    // var inner;
    // function outer() {


    //   var aa = 200;
    //   inner = function () {
    //     aa++
    //     console.log(aa);
    //   }
    // }
    // outer()
    // var aa = 300;
    // inner()
    // inner()
    // inner()
    // inner()
    // inner()
    // inner()

    // outer()

    // inner()
    // inner()
    // inner()


    // 函数定义一次,可以多次调用,每一次调用都会产生新的闭包,也就是说闭包里的语句都是全新的,所处环境也是全新的

    // 闭包会导致原有的做作用域链不会释放,造成内存泄露

    // 闭包的作用
    // 可以做缓存
    // function outer() {
    //   var num = 100;
    //   function add() {
    //     num++;
    //     console.log(num)
    //   }
    //   function remove() {
    //     num--;
    //     console.log(num)
    //   }
    //   return [add, remove]
    // }
    // var myArr = outer();
    // myArr[0]();
    // myArr[1]()
    // myArr[0]();
    // myArr[0]();
    // myArr[0]();
    // myArr[1]()
    // myArr[1]()
    // myArr[1]()

    // 什么是闭包
    // 当内部的函数被保存在了外部时,由于内部函数的作用域链上存在着内部函数创建时的作用域
    // 环境(父函数和祖先函数的AO对象,以及全局的GO对象),导致内部函数可以顺着作用域链寻找变量,
    // 所以形成了闭包,同时内部函数的作用链无法被垃圾回收机制回收,导致内存泄露

  </script>
</body>

</html>